# The MIT License (MIT)
#
# Copyright (c) 2014-2015 WUSTL ZPLAB
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Authors: Erik Hvatum, Zach Pincus

import ctypes
import atexit
import numpy

# import all the autogenerated functions and definitions
# note: also pulls in common which provides AndorError and several other constants
from . import wrapper
from .wrapper import *

# Provided for reference purposes, the FeatureStrings list contains all the "feature strings"
# listed in the Andor SDK documentation. The value given for the Feature argument to functions
# provided by this module should be a string appearing in this list.
FeatureStrings = [
    'AccumulateCount',
    'AcquisitionStart',
    'AcquisitionStop',
    'AOIBinning',
    'AOIHBin',
    'AOIHeight',
    'AOILeft',
    'AOIStride',
    'AOITop',
    'AOIVBin',
    'AOIWidth',
    'AuxiliaryOutSource',
    'BaselineLevel',
    'BitDepth',
    'BufferOverflowEvent',
    'BytesPerPixel',
    'CameraAcquiring',
    'CameraDump',
    'CameraModel',
    'CameraName',
    'ControllerID',
    'CycleMode',
    'DeviceCount',
    'DeviceVideoIndex',
    'ElectronicShutteringMode',
    'EventEnable',
    'EventsMissedEvent',
    'EventSelector',
    'ExposureTime',
    'ExposureEndEvent',
    'ExposureStartEvent',
    'FanSpeed',
    'FirmwareVersion',
    'FrameCount',
    'FrameRate',
    'FullAOIControl',
    'ImageSizeBytes',
    'InterfaceType',
    'IOInvert',
    'IOSelector',
    'LUTIndex',
    'LUTValue',
    'MaxInterfaceTransferRate',
    'MetadataEnable',
    'MetadataFrame',
    'MetadataTimestamp',
    'Overlap',
    'PixelCorrection',
    'PixelEncoding',
    'PixelHeight',
    'PixelReadoutRate',
    'PixelWidth',
    'PreAmpGain',
    'PreAmpGainChannel',
    'PreAmpGainControl',
    'PreAmpGainSelector',
    'ReadoutTime',
    'RollingShutterGlobalClear',
    'RowNExposureEndEvent',
    'RowNExposureStartEvent',
    'SensorCooling',
    'SensorHeight',
    'SensorTemperature',
    'SensorWidth',
    'SerialNumber',
    'SimplePreAmpGainControl',
    'SoftwareTrigger',
    'SoftwareVersion',
    'SpuriousNoiseFilter',
    'SynchronousTriggering',
    'TargetSensorTemperature',
    'TemperatureControl',
    'TemperatureStatus',
    'TimestampClock',
    'TimestampClockFrequency',
    'TimestampClockReset',
    'TriggerMode',
    'VerticallyCenterAOI'
]


_AT_HANDLE_SYSTEM = 1

def _init_core_lib(corepath):
    if wrapper._at_core_lib is not None:
        return

    wrapper._at_core_lib = ctypes.CDLL(corepath)
    wrapper._setup_core_functions()
    wrapper._at_core_lib.AT_InitialiseLibrary()
    atexit.register(wrapper._at_core_lib.AT_FinaliseLibrary)

def _init_util_lib(utilpath):
    if wrapper._at_util_lib is not None:
        return

    wrapper._at_util_lib = ctypes.CDLL(utilpath)
    wrapper._setup_util_functions()
    wrapper._at_util_lib.AT_InitialiseUtilityLibrary()
    atexit.register(wrapper._at_util_lib.AT_FinaliseUtilityLibrary)

def _init_camera(desired_camera):
    if wrapper._at_camera_handle is not None:
        return

    devices_attached = wrapper._at_core_lib.AT_GetInt(_AT_HANDLE_SYSTEM, "DeviceCount")
    if devices_attached == 0:
        raise AndorError('No Andor SDK3 devices detected. Is the camera turned on?')
    # Even on the scope machine, the default Andor configuration includes two
    # virtual cameras, for a total of three camera devices. A hardware camera
    # will take device index 0, provided you have only one hardware camera, and
    # we are very clearly working under this assumption. We might then test
    # this assumption by querying the camera's name and ensuring that it matches
    # the name of our hardware camera:
    wrapper._at_camera_handle = wrapper._at_core_lib.AT_Open(0)
    actual_camera = GetString('CameraModel')
    if False:#actual_camera != desired_camera:
        wrapper._at_core_lib.AT_Close(wrapper._at_camera_handle)
        wrapper._at_camera_handle = None
        raise AndorError('Model name of Andor device 0, "' + actual_camera +
                         '", does not match the desired camera model name, "' +
                         desired_camera + '".')
    atexit.register(wrapper._at_core_lib.AT_Close, wrapper._at_camera_handle)

def initialize(desired_camera):
    """Initialize the andor libraries and make sure that the connected camera
    matches the desired camera model name. (If the camera is turned off, Andor
    will often provide a "simulated camera" instead; this check avoids that
    gotcha.)"""
    _init_core_lib('libatcore.so')
    _init_util_lib('libatutility.so')
    _init_camera(desired_camera)

